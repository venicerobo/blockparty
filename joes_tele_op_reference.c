#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Joe's Reference Implementation
//
// This is a reference tele-op program for you to read and steal from.  It should not be used
// verbatim in any competition, because it was not written by a member of the club.

#include "JoystickDriver.c"

#define DEADBAND 10
#define JOYSTICK_MAX 128

float scoop_servo_position = servo[servo1];
float scoop_servo_joystick_divisor = 300;

// This is our classic deadband and rescaling code.  This takes the raw value of a joystick,
// zeroes out the close-to-zero values, and rescales the value to max out near 100 (which is
// the maximum value used to drive the motors), and to move a lot slower at the lower values
// by following a square function instead of a linear function.  Here's an idea of how this
// makes the joystick respond when the DEADBAND is 10 and the JOYSTICK_SCALE is 128:
//
//   raw joystick value        cleaned up value
//             -10 - 10                       0
//                +/-15                  +/-0.2
//                +/-30                  +/-3.1
//                +/-50                 +/-12.5
//                +/-70                 +/-28.1
//               +/-100                 +/-63.3
//               +/-128                +/-108.8
//
// Note that the upper half of the raw joystick values cover 80% of the possible values for
// the output.
int cleanup(int x) {
  if (x > DEADBAND)
    return (x - DEADBAND) * (x - DEADBAND) /  JOYSTICK_MAX;
  if (x < -DEADBAND)
    return (x + DEADBAND) * (x + DEADBAND) / -JOYSTICK_MAX;
  return 0;
}

int max(int x, int y) {
	if (x > y) return x;
	return y;
}

int min(int x, int y) {
	if (x < y) return x;
	return y;
}

void initializeRobot()
{
	scoop_servo_position = 0;
	servo[servo1] = (int) scoop_servo_position;

  bFloatDuringInactiveMotorPWM = false;
  return;
}

task main()
{
  initializeRobot();

  waitForStart();

  while (true)
  {
    getJoystickSettings(joystick);
		nxtDisplayString(1, "j1:x:%d y:%d", joystick.joy1_x1, joystick.joy1_y1);
		nxtDisplayString(2, "j2:x:%d y:%d", joystick.joy1_x2, joystick.joy1_y2);

    int left_wheel_power = cleanup(joystick.joy1_y1);
    int right_wheel_power = cleanup(joystick.joy1_y2);
    motor[motorD] = left_wheel_power;
    motor[motorE] = -right_wheel_power;

    int arm_power = cleanup(joystick.joy2_y1);
    motor[motorF] = arm_power;
    motor[motorG] = arm_power;

    int winch_up = joystick.joy2_Buttons & 8;
    int winch_down = joystick.joy2_Buttons & 16;
    if (winch_up && !winch_down) {
    	motor[motorH] = 20;
    }
    if (winch_down && !winch_up) {
    	motor[motorH] = -20;
    }

    int scoop_movement = cleanup(joystick.joy2_y2);

    float new_scoop_servo_position = scoop_servo_position - scoop_movement /
        scoop_servo_joystick_divisor;
    new_scoop_servo_position = max(0, new_scoop_servo_position);
    new_scoop_servo_position = min(255, new_scoop_servo_position);
    scoop_servo_position = new_scoop_servo_position;
    servo[servo1] = (int) scoop_servo_position;
  }
}
